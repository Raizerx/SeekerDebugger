Extension { #name : #RBProgramNode }

{ #category : #'*Seeker' }
RBProgramNode >> @ aNumberOrNodeIndex [

	"In the future this will be extended to suppory other expression (#last, etc)"

	aNumberOrNodeIndex isNumber ifTrue: [ "Consider it as if it is a bytecode index" 
		^ aNumberOrNodeIndex nthBytecode findIn: self ].
	(aNumberOrNodeIndex class inheritsFrom: SkXNodeIndex) ifTrue: [ 
		^ aNumberOrNodeIndex findIn: self ].
	^ self error: 'unsupported argument type'
]

{ #category : #'*Seeker' }
RBProgramNode >> fullPath [

	"The node complete path from the method node, using the node path notation"

	| ownerNode |
	"ownerNode is a MethodNode or BlockNode"
	ownerNode := self ownerNode.
	ownerNode isMethod ifTrue: [ ^ self localPath ].
	^ ownerNode fullPath @ self
]

{ #category : #'*Seeker' }
RBProgramNode >> localPath [

	"The node local path, from the nearest method or block node, using the node path notation"

	^ SkXNodePath new @ self
]

{ #category : #'*Seeker' }
RBProgramNode >> localPathNotation [

	| nodeIndex ownerNode nodeIndexExpression |
	ownerNode := self ownerNode.
	nodeIndex := self ordinalIndex.
	nodeIndexExpression := nodeIndex
		                       ifNil: [ '' ]
		                       ifNotNil: [ '@ ' , nodeIndex asString ].
	ownerNode isMethod
		ifTrue: [ 
			^ self methodNode methodClass name , '>>#'
			  , self methodNode selector , ' ' , nodeIndexExpression ]
		ifFalse: [ ^ nodeIndexExpression ]
]

{ #category : #'*Seeker' }
RBProgramNode >> nextSibling [

	| currentIndex siblings targetIndex |
	currentIndex := self ordinalIndex.
	siblings := self ordinatedSiblings.
	targetIndex := currentIndex + 1.
	targetIndex > siblings size ifTrue: [ ^ nil ].
	^ siblings at: targetIndex
]

{ #category : #'*Seeker' }
RBProgramNode >> ordinalIndex [

	"The index of the generated bytecode that corresponds to this node"

	^ self ownerNode bcToASTCache ordinalIndexOf: self
]

{ #category : #'*Seeker' }
RBProgramNode >> ordinallyCompareTo: anotherNode [

	"Returns: 
- A negative number if self bytecode is ordinally located before anotherNode's bytecode.
- A positive number if self bytecode is ordinally located after anotherNode's bytecode.
- Zero if it is the same node.
- nil if the nodes belong to different ownerNodes
 "

	| leftOwner rightOwner |
	self == anotherNode ifTrue: [ ^ 0 ].
	leftOwner := self ownerNode.
	rightOwner := anotherNode ownerNode.
	leftOwner == rightOwner ifFalse: [ 
		^ nil "Can only compare ordinality of nodes with same owner" ].
	^ self ordinalIndex - anotherNode ordinalIndex
]

{ #category : #'*Seeker' }
RBProgramNode >> ordinatedChildren [

	"if self is not a mthod node or block, this will fail"

	^ self bcToASTCache ordinatedNodes
]

{ #category : #'*Seeker' }
RBProgramNode >> ordinatedSiblings [

	^ self ownerNode bcToASTCache ordinatedNodes
]

{ #category : #'*Seeker' }
RBProgramNode >> ownerNode [

	"The owner Node' of this node. Could be a methodOrBlockNode ."

	parent ifNil: [ ^ self "Case for the method node" ].
	^ parent methodOrBlockNode
]

{ #category : #'*Seeker' }
RBProgramNode >> previousSibling [

	| currentIndex siblings targetIndex |
	currentIndex := self ordinalIndex.
	siblings := self ordinatedSiblings.
	targetIndex := currentIndex - 1.
	targetIndex < 1 ifTrue: [ ^ nil ].
	^ siblings at: targetIndex
]

{ #category : #'*Seeker' }
RBProgramNode >> sequenceNode [

	"Return your owner sequence node"

	self isSequence ifTrue: [ ^ self ].
	parent ifNil: [ ^ nil ].

	^ parent sequenceNode
]

{ #category : #'*Seeker' }
RBProgramNode >> statementIndex [

	"statement index in the ownin sequence. Block nodes return the statement where they are defined."

	| st |
	st := self statementNode.
	^ st
		  ifNil: [ ^ nil ]
		  ifNotNil: [ ^ self ownerNode bcToASTCache statementIndexOf: st ]
]

{ #category : #'*Seeker' }
RBProgramNode >> statementNotation [

	| st |
	st := SkXStatementNotation new.
	"For the moment, only supports method and not blocks"
	st sequenceID: self methodNode method.
	st statementIndex:
		(SkNodeHelpers statementNodeIndexInSequence: self statementNode).
	^ st
]
